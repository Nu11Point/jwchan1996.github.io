<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[v-bind 动态拼接参数]]></title>
    <url>%2F2018%2F12%2F29%2Fvue_v-bind%2F</url>
    <content type="text"><![CDATA[#场景在业务开发中常常需要对元素属性进行动态绑定比如 v-for 下遍历 img 绑定 src 地址传统方法用的是拼接 dom 元素字符串，再把字符串插入到文档流里，对于使用 vue，我们不必再频繁地处理 dom我们可以使用 v-bind 来处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错，需要处理妥当。 #示例动态拼接，以 v-for 为例： &lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;(item,index) in items&quot; :key=&quot;index&quot;&gt; &lt;img :src=&quot;&apos;http://image.baidu.com&apos;+item.thumbnail&quot; alt=&quot;图片&quot;&gt; &lt;/div&gt; &lt;a :href=&quot;&apos;http://user.baidu.com?uid=&apos;+uid&quot;&gt;跳转用户界面的链接&lt;/a&gt; &lt;a v-bind:href=&quot;url&quot;&gt;github&lt;/a&gt; &lt;/div&gt; &lt;script&gt; new vue({ el: &apos;#app&apos;, data: { items: [{ name: &apos;baidu&apos;, thumbnail: &apos;/public/123456.jpg&apos; }, { name: &apos;github&apos;, thumbnail: &apos;/public/234567.jpg&apos; }], uid: 123, url: &apos;https://github.com&apos; } }) &lt;/dcript&gt; 🍳 以上示例是动态拼接字符串的正确方式: 是 v-bind 的缩写，指令可以接一个&quot;参数&quot;，这个&quot;参数&quot;在指令后面以冒号表示，如 &lt;a v-bind:href=&quot;url&quot;&gt;github&lt;/a&gt; 的 url 就是参数，与 vue 实例数据绑定。 🍭 谨记：v-bind 属性内必须为合法的 JavaScript 表达式无论是拼接字符串还是三目运算表达式，返回的都是合法 JavaScript 表达式返回的结果。v-bind 表达式结果的类型除了字符串之外，还可以是对象或数组。 🐯 点击查看 @v-bind 更多特性与用法 yo ~ .img_v-bind{ margin-top: 40px !important; transition: 0.2s all; } .img_v-bind:hover{ transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; }]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 axios post 请求的坑]]></title>
    <url>%2F2018%2F12%2F25%2Faxios_post%2F</url>
    <content type="text"><![CDATA[Axios Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 踩坑按照 axios 官网例子使用 axios.post 发起请求传递 json，后台接受到的数据为空浏览器报错，然后使用 restlet 请求却可以正常返回数据经过一波操作之后，最后发现是因为 axios 的默认提交方式是 application/json 这种而后台接口的处理的是常见的 post 编码 application/x-www-form-urlencoded 这种后台接收到的是经过序列化后的 json 字符串，所以没办法读取值出来所以，问题找出来了，就可以解决问题了 解决既然我们知道 axios post 方法默认使用 application/json 格式编码数据，那么解决方案就有两种，一是后台改变接收参数的方法，另一种则是将 axios post 方法的编码格式修改为 application/x-www-form-urlencoded，这样就不需要后台做什么修改了。 第一种 后台解析对接收到的参数进行解析，生成 json 对象再对 json 对象进行处理以 php 为例123$content = $GLOBALS[&quot;HTTP_RAW_POST_DATA&quot;]; #获取原始数据$re = json_decode($content); #生成json对象...... 这种方法最为简便，不过……如果接口已经写好了，且接口很多，要改的话，还是要花点时间…… 第二种 前端处理数据在查阅文档之后，发现 axios 允许在向服务器发送前，修改请求数据增加 transformRequest 方法参数：1234567891011121314&#123; url: &apos;/user&apos;, // url 是用于请求的服务器 URL method: &apos;post&apos;, // method 是创建请求时使用的方法,默认是 get // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 &apos;PUT&apos;, &apos;POST&apos; 和 &apos;PATCH&apos; 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) &#123; // 对 data 进行任意转换处理 return data; &#125;],], 下面是处理代码：12345678910&#123; //对提交的数据格式进行转换 transformRequest: [function (data) &#123; let ret = &apos;&apos; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos; &#125; return ret &#125;],&#125; 完整代码是：123456789101112131415161718axios(&#123; method: &apos;post&apos;, url: &apos;https://api.github.com/user&apos;, #接口地址，仅参考 data: &#123; action: &quot;getUserMessage&quot;, userId: 100 &#125;, //对提交的数据格式进行转换（post方法的坑） transformRequest: [function (data) &#123; let ret = &apos;&apos; for (let it in data) &#123; ret += encodeURIComponent(it) + &apos;=&apos; + encodeURIComponent(data[it]) + &apos;&amp;&apos; &#125; return ret &#125;]&#125;).then( response =&gt; &#123; console.log(response.data)&#125;) 🎄然后就可以正常获取数据了~最后，圣诞节快乐🎅~ 附：当参数是 JSON 字符串时，默认的 Content-Type 是 application/x-www-form-urlencoded12345678910axios.post(&apos;/user&apos;, JSON.stringify(&#123; firstName: &apos;Fred&apos;, lastName: &apos;Flintstone&apos; &#125;)) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error);&#125;); 此时传递的参数是 Form Data 格式 key : value1&#123;&quot;firstName&quot;:&quot;Fred&quot;,&quot;lastName&quot;:&quot;Flintstone&quot;&#125;: 如上。这是一个无效的数据，key为 {&quot;firstName&quot;:&quot;Fred&quot;,&quot;lastName&quot;:&quot;Flintstone&quot;}，value 为空。 🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎅🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄🎄]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 实现代码托管]]></title>
    <url>%2F2018%2F12%2F20%2Fgit_command%2F</url>
    <content type="text"><![CDATA[#git_command{ /**设置缩放**/ -webkit-transition: 0.2s all; -moz-transition: 0.2s all; -ms-transition: 0.2s all; transition: 0.2s all; } #git_command:hover{ -webkit-transform: scale(1.02,1.02); -moz-transform: scale(1.02,1.02); -ms-transform: scale(1.02,1.02); transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; } 前置条件: 在 github 上新建仓库，本地与远端已实现身份认证 🔶 第一步: 建立 git 仓库(本地)1git init 🔶 第二步: 将项目所有文件添加到待上传列表中1git add . 🔶 第三步: 将 add 的文件 commit 到本地仓库(并添加注释)1git commit -m &quot;注释语句&quot; 🔶 第四步: 将本地仓库关联到 github 远程仓库1git remote add origin https://github.com/jwchan1996/pizza-app.git #仓库地址 🔶 第五步: 将代码上传到 github 远程仓库(推送)12# 使用 -u 代表指定默认主机，这样以后就可以不加任何参数使用 git pull 与 git pushgit push -u origin master 🌖 注意: 多人协作每次同步代码需要先将代码拉下来(拉取) 👉 首先将代码提交到本地仓库12git add .git commit -m &quot;注释语句&quot; 👉 将远程代码拉取下来1git pull origin master 👉 然后再将本地仓库代码上传1git push origin master 至此，github 代码托管就完成啦(๑&gt;؂&lt;๑） 🌘 附: Git基本常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061mkdir XX #创建一个空目录 XX指目录名pwd #显示当前目录的路径。git init #把当前的目录变成可以管理的git仓库，生成隐藏.git文件。git add XX #把xx文件添加到暂存区去。git commit –m “XX” #提交文件 –m 后面的是注释。git status #查看仓库状态git diff XX #查看XX文件修改了那些内容git log #查看历史记录git reset --hard HEAD^ 或者 git reset --hard HEAD~ #回退到上一个版本git reset –hard HEAD~100 #回退到100个版本cat XX #查看XX文件内容git reflog #查看历史记录的版本号idgit checkout -- XX #把XX文件在工作区的修改全部撤销。git rm XX #删除XX文件git remote add origin https://github.com/jwchan1996/pizza-app.git #关联一个远程库git push –u(第一次要用-u 以后不需要) origin master #把当前master分支推送到远程库git clone https://github.com/jwchan1996/pizza-app.git #从远程库中克隆git checkout –b dev #创建dev分支 并切换到dev分支上git branch #查看当前所有的分支git checkout master #切换回master分支git merge dev #在当前的分支上合并dev分支git branch –d dev #删除dev分支git branch name #创建分支git stash #把当前的工作隐藏起来 等以后恢复现场后继续工作git stash list #查看所有被隐藏的文件列表git stash apply #恢复被隐藏的文件，但是内容不删除git stash drop #删除文件git stash pop #恢复文件的同时 也删除文件git remote #查看远程库的信息git remote –v #查看远程库的详细信息git push origin master #Git会把master分支推送到远程库对应的远程分支上 完毕！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11月份 / Summary]]></title>
    <url>%2F2018%2F12%2F01%2Fsummary_201811%2F</url>
    <content type="text"><![CDATA[#summary_201811_01, #summary_201811_02, #summary_201811_03, #summary_201811_04, #summary_201811_05, #summary_201811_06, #summary_201811_07, #summary_201811_08, #summary_201811_09{ /**设置缩放**/ -webkit-transition: 0.2s all; -moz-transition: 0.2s all; -ms-transition: 0.2s all; transition: 0.2s all; } #summary_201811_01:hover, #summary_201811_02:hover, #summary_201811_03:hover, #summary_201811_04:hover, #summary_201811_05:hover, #summary_201811_06:hover, #summary_201811_07:hover, #summary_201811_08:hover, #summary_201811_09:hover{ -webkit-transform: scale(1.02,1.02); -moz-transform: scale(1.02,1.02); -ms-transform: scale(1.02,1.02); transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; } 雉青十一，渐入佳境 十一月份，是梳理的月份，是持续学习与渴望coding的。 关于产品 解决了用户需求，实现了产品目标对用户和公司来说是个好产品。而对于产品本身，应该从设计实现的每个细节角度来评判其是不是个好产品。每个功能是不是以最优的用户体验和技术实现方式来完成的。这个考验的是产品、设计、开发人员的功底，协作程度、责任心等各个方面。功能设计方面：是否在协调用户体验和产品目标上找到最佳的平衡点？是否在最合适的场合为用户呈现了他需要的功能和帮助？是否考虑到了用户所以的使用场景？视觉设计方面：画面布局是否美观？颜色、字体是否恰到好处？动效设计是否流畅？用户体验方面：操作流程是否简单易理解？功能的使用是否存在技术门槛？是否考虑到了每个细节上对用户的引导？技术架构实现方面：技术选型是否合理？正常异常分支是否都考虑到位？测试是否全面？性能是否过关？是否考虑到了多平台、多机型的适配？从专业的产品设计和技术视角评判一款产品。每个功能都是完美的操作体验，每个页面都是最美的视觉效果，以最优的代码实现，最低的故障率，最快的响应速度呈现给用户，才是好产品。举个例子，印象笔记这款产品，无论是移动端还是PC端、Mac端，其产品设计实现都非常完美。画面美观、设计独特、交互体验好、运行流畅、就连付费功能展示的时机也是恰到好处，不会让用户厌烦。从产品设计角度来说，印象笔记是款好产品。 (⊙o⊙)…所以如何开发出一款好的产品，作为开发人员，无论是功能交互还是UI设计，还是要修一下的。除了看交互设计书，最重要的就是上手体验了，所以接下来上手了一些小而美、做的精致的APP，看一下别人是怎么设计界面，怎么做功能交互的。一言、MOZIK、留白、落网 这几个算是小而美精致，掘金、慕课网、SegmentFault、人人都是产品经理 这些也是优美。 01~10号 11月份开始，首先开始的是对用户界面的设计，因为设计狮的空缺，只能自己上了。趁着当当搞满减活动，买了几本UI设计跟产品交互的书。这段时间也比较关注产品设计，所以一些设计网站和产品社区也经常逛，比如站酷、我是PM这些，提供了灵感以及开阔眼界和思路。色彩的应用有了点头绪，对于色彩的选择真的很重要： 接下来是接口设计还有维护以前的项目。 包括优化了UI界面以及用户操作，修复隐藏的bug。其中，websocket得到了健壮性的保证。 11~20号 用了四年的笔记本，终于，我重装了系统，如获新生。之前可是打个字，搜狗输入法都卡个很久，更别说打开浏览器，打开编译器，打开虚拟机。其中最主要让我下定决心重装的原因是Photoshop因为内存不够打不开，图都P不了，忍无可忍，终于对它下手了，虽然重装软件配置环境什么的很多。然后，经过一周的资料搜索（工作内容）以及讨论会议。在PPAP群里偶然提起了Flutter之后，我决定花点精力去了解这个东西，之前是知道这个东西的，但是没有深入了解。首先是环境的搭建，刚开始按着教程搭，开发编辑器一个是vscode，另一个是Android Studio。因为刚开始嫌Android Studio太重，所以以为不用装，就出现命令运行不通过。提醒Android Studio未安装，装了之后，又出现其他问题。后面配置好了环境，终于可以跑起来了，60FPS极致丝滑： 很鸡冻有木有(๑&gt;؂&lt;๑） 21~30号 上周的讨论依然没有结果，大方向这些东西没定好（工作内容），接下来继续分析（册子）。发挥想象力，APP项目UI主题色与结构改变之后的界面： 再一次证明了色彩的重要性(๑&gt;؂&lt;๑）。 因为自己计划着手微信小程序项目，PPAP之前是有一个产品雏形的，一直没落实，也没想好底层逻辑，也没进展，后面我就想把这个带起来，就牵了个头，安排任务给他们（虽然技术成长需要时间），算是有了个开始吧，虽然现阶段文档不齐全，技术暂时还对不上。也是为了实践计划，在码云上搭建了项目仓库，开始协作开发。也是由于PPAP年轻人技术不同步,包括前端后端，以及产品逻辑不完善，暂时也没个法子。现在就是搭个项目作为DEMO来作为pratice: 也就差不多这样子啦(๑&gt;؂&lt;๑），12月份也是个需要奋斗的月份，接下来把miniprogram过掉，就可以LU一遍webpack4了，后面就要研究一下Flutter了，期待12月23号的 Google DevFest 2018广州国际嘉年华~]]></content>
      <categories>
        <category>生活与工作</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初探和实现websocket心跳重连]]></title>
    <url>%2F2018%2F11%2F21%2Fwebsocket%2F</url>
    <content type="text"><![CDATA[心跳重连缘由websocket是前后端交互的长连接，前后端也都可能因为一些情况导致连接失效并且相互之间没有反馈提醒。因此为了保证连接的可持续性和稳定性，websocket心跳重连就应运而生。在使用原生websocket的时候，如果设备网络断开，不会触发websocket的任何事件函数，前端程序无法得知当前连接已经断开。这个时候如果调用websocket.send方法，浏览器就会发现消息发不出去，便会立刻或者一定短时间后（不同浏览器或者浏览器版本可能表现不同）触发onclose函数。后端websocket服务也可能出现异常，连接断开后前端也并没有收到通知，因此需要前端定时发送心跳消息ping，后端收到ping类型的消息，立马返回pong消息，告知前端连接正常。如果一定时间没收到pong消息，就说明连接不正常，前端便会执行重连。为了解决以上两个问题，以前端作为主动方，定时发送ping消息，用于检测网络和前后端连接问题。一旦发现异常，前端持续执行重连逻辑，直到重连成功。 如何实现在websocket实例化的时候，我们会绑定一些事件：1234567891011121314var ws = new WebSocket(url);ws.onclose = function () &#123; //something&#125;;ws.onerror = function () &#123; //something&#125;; ws.onopen = function () &#123; //something&#125;;ws.onmessage = function (event) &#123; //something&#125; 如果希望websocket连接一直保持，我们会在close或者error上绑定重新连接方法。123456ws.onclose = function () &#123; reconnect();&#125;;ws.onerror = function () &#123; reconnect();&#125;; 这样一般正常情况下失去连接时，触发onclose方法，我们就能执行重连了。 那么针对断网的情况的心跳重连，怎么实现呢。简单的实现：123456789101112131415161718192021var heartCheck = &#123; timeout: 60000,//60ms timeoutObj: null, reset: function()&#123; clearTimeout(this.timeoutObj); this.start(); &#125;, start: function()&#123; this.timeoutObj = setTimeout(function()&#123; ws.send("HeartBeat"); &#125;, this.timeout) &#125;&#125;ws.onopen = function () &#123; heartCheck.start();&#125;;ws.onmessage = function (event) &#123; heartCheck.reset();&#125; 如上代码，heartCheck 的 reset和start方法主要用来控制心跳的定时。 什么条件下执行心跳：当onopen也就是连接上时，我们便开始start计时，如果在定时时间范围内，onmessage获取到了后端的消息，我们就重置倒计时，距离上次从后端获取到消息超过60秒之后，执行心跳检测，看是不是断连了，这个检测时间可以自己根据自身情况设定。 判断前端ws断开(断网但不限于断网的情况）：当心跳检测send方法执行之后，如果当前websocket是断开状态(或者说断网了)，发送超时之后，浏览器的ws会自动触发onclose方法，重连也执行了（onclose方法体绑定了重连事件），如果当前一直是断网状态，重连会2秒（时间是自己代码设置的）执行一次直到网络正常后连接成功。如此一来，我们判断前端主动断开ws的心跳检测就实现了。为什么说是前端主动断开，因为当前这种情况主要是通过前端ws的事件来判断的，后面说后端主动断开的情况。 在测试websocket超时时间，又发现了一些新的问题 在chrome中，如果心跳检测 也就是websocket实例执行send之后，15秒内没发送到另一接收端，onclose便会执行。那么超时时间是15秒。 Firefox在断网7秒之后，直接执行onclose。说明在Firefox中不需要心跳检测便能自动onclose。 同一代码， reconnect方法 在chrome 执行了一次，Firefox执行了两次。当然我们在几处地方（代码逻辑处和websocket事件处）绑定了reconnect()，所以保险起见，我们还是给reconnect()方法加上一个锁，保证只执行一次 目前来看不同的浏览器，有不同的机制，无论浏览器websocket自身会不会在断网情况下执行onclose，加上心跳重连后，已经能保证onclose的正常触发。 判断后端断开：如果后端因为一些情况断开了ws，是可控情况下的话，会下发一个断连的消息通知，之后才会断开，我们便会重连。如果因为一些异常断开了连接，我们是不会感应到的，所以如果我们发送了心跳一定时间之后，后端既没有返回心跳响应消息，前端又没有收到任何其他消息的话，我们就能断定后端主动断开了。一点特别重要的发送心跳到后端，后端收到消息之后必须返回消息，否则超过60秒之后会判定后端主动断开了。再改造下代码: 123456789101112131415161718192021222324252627282930313233var heartCheck = &#123; timeout: 60000,//60ms timeoutObj: null, serverTimeoutObj: null, reset: function()&#123; clearTimeout(this.timeoutObj); clearTimeout(this.serverTimeoutObj); this.start(); &#125;, start: function()&#123; var self = this; this.timeoutObj = setTimeout(function()&#123; ws.send("HeartBeat"); self.serverTimeoutObj = setTimeout(function()&#123; ws.close();//如果onclose会执行reconnect，执行ws.close()就行了.如果直接执行reconnect 会触发onclose导致重连两次 &#125;, self.timeout) &#125;, this.timeout) &#125;,&#125;ws.onopen = function () &#123; heartCheck.start();&#125;;ws.onmessage = function (event) &#123; heartCheck.reset();&#125;ws.onclose = function () &#123; reconnect();&#125;;ws.onerror = function () &#123; reconnect();&#125;; PS： 因为目前这种方式会一直重连如果没连接上或者断连的话，如果有两个设备同时登陆并且会踢另一端下线，一定要发送一个踢下线的消息类型，这边接收到这种类型的消息，逻辑判断后就不再执行reconnect，否则会出现一只相互挤下线的死循环。 此篇博文转自@子暮大诗人，代码已封装为库websocket-heartbeat-js]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10月份 / Summary]]></title>
    <url>%2F2018%2F11%2F01%2Fsummary_201810%2F</url>
    <content type="text"><![CDATA[#summary_201810_01, #summary_201810_02, #summary_201810_03, #summary_201810_04, #summary_201810_05, #summary_201810_06{ /**设置缩放**/ -webkit-transition: 0.2s all; -moz-transition: 0.2s all; -ms-transition: 0.2s all; transition: 0.2s all; } #summary_201810_01:hover, #summary_201810_02:hover, #summary_201810_03:hover, #summary_201810_04:hover, #summary_201810_05:hover, #summary_201810_06:hover{ -webkit-transform: scale(1.02,1.02); -moz-transform: scale(1.02,1.02); -ms-transform: scale(1.02,1.02); transform: scale(1.02,1.02); box-shadow: 5px 5px 30px #999; cursor: pointer; } 未央十月，清风微似梦 十月份于我，是一个慵懒的月份，也是个探索的月份，没有coding的紧迫感，也没有八九月份的热情。 01~07号 在经历过对未知领域与技术的了解与实践后，九月末搭建了博客，接着就开启了一个星期的国庆假期，在经过了佛性的几天后，抓着假期的尾巴，去了长隆水上乐园，太阳很猛，水温很凉，全程玩下来整整一个下午，单论玩真的很值，很刺激，过后泡个温泉浴，身心舒畅，回来站上体重秤一秤发现轻了两斤，血亏！(因为博主9月中旬制定了增重计划)，建议需要减肥的同学可以去玩一哈…… 急驰竞赛 08~14号 十一假期回来，继续捣鼓博客网站。在观摩了许多大佬的网站之后，开始了对自己博客的美化之路。除此之外，拜读了许多大佬的文章之后，感叹于他们对技术的执着，其中很大部分都还是高中生，或者大多数是ACG爱好者，大概是“用爱发电”吧。这个星期主要是捣鼓Hexo、收集资源以及观摩大佬博客，达到自惭形愧以自我鞭笞。 周末回去了大学城，在中心湖周围逛了一下，端庄地坐在草地上，喝着益禾堂烤奶，看着岛外的各个家庭一家几口的在这边野餐露营，放着风筝，孩子打闹嬉戏，也是一片和谐有爱… 中心湖草地 15~21号 本周继续研究Hexo，开始着手发表文章，完成“关于”页面的编写，也是在本周，在收集资源的过程中，从吐槽站的群里发现了个大佬，后面发现了clicli.us，技术宅是真的改变世界，我不由得去思考二次元文化对他们的影响（或许真的有丶东西？喜欢二次元的不一定是大佬，但大佬很多都是二次元爱好者？）。于是，一是因为自己喜欢动漫，虽然没有每部番都追，但是追的番都会追完，二是为了给博客找素材，我也开始进入ACG的圈子一探究竟…… 周六部门团建，帽峰山之旅。帽峰山之貌，山坡陡峭，沟谷深幽，地形多变，群山漭漭，鸟语花香，幽静怡人。遂登顶开黑，组队互殴，甚是快哉。 周日在科学中心巨幕影院看了《无双》，真真假假，真是”钞”级大片。 流水账的视觉…… 山湖 登顶 开黑 22~31号 本周刚好是博主增重计划的第一个周期，目标一个月增重十斤，你猜怎么着？当然是……完成目标！哇，三分锻炼七分吃，这七分有丶费钱。啊啊啊啊啊，本周主要是对下一个项目进行需求分析与界面设计，还有就是对上个APP项目进行优化和debug。 以前对于移动端设计简直小白，很多都还是web的思维模式，也是因为对移动端设计页面的不了解，后面见多了，会类比，什么样的界面更加美观，什么样的操作有更好的用户体验，这些东西还需要慢慢学习……当然，现在对于界面样式调试的熟练度比半年前进步了，可以也愿意去尝试新属性带来的效果……写代码还是得靠经验啊，踩的坑多了，研究过了对知识点的掌握才会更深刻。代码可以隔一段时间去review一下，你会发现以前写的代码思维跟你现在写代码的思维的区别。对以前糟糕的代码进行重构，减少代码间的耦合性，预留扩展功能，维护起来就会减少很多不必要的麻烦！ 展望 话说写文章真的很费劲，emmmm……要花很多心思……但，十一月，注定是奋斗的月份,我要打鸡血了！！！！Boooooommmmmm~冲鸭！]]></content>
      <categories>
        <category>生活与工作</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[诗 / Poem]]></title>
    <url>%2F2018%2F10%2F17%2Fpoem_1%2F</url>
    <content type="text"><![CDATA[所遇即所爱幸之所在]]></content>
      <categories>
        <category>诗词</category>
      </categories>
      <tags>
        <tag>Learn</tag>
        <tag>诗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序 / INTRO]]></title>
    <url>%2F2018%2F09%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[生命的幻影穿过狭长的岁月向东向西消失在暮色里—— 改编自《生命幻想曲》顾城]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Hello World</tag>
        <tag>Learn</tag>
        <tag>买了否冷</tag>
      </tags>
  </entry>
</search>
